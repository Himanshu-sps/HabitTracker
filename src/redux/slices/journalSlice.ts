import {
  createSlice,
  createAsyncThunk,
  ActionReducerMapBuilder,
  PayloadAction,
} from '@reduxjs/toolkit';
import { analyzeSentiment, suggestHabitsFromAI } from '@/services/AIServices';
import { BaseResponseType, SentimentResult } from '@/type';
import {
  fetchAllJournalsForUser,
  saveJournalEntry,
  deleteJournalEntry,
} from '@/services/FirebaseService';
import { JournalType } from '@/type';
import { fetchJournalEntry } from '@/services/FirebaseService';
import { invalidateHistoryCache } from './historySlice';
import { DATE_FORMAT_ZERO, formatDate } from '@/utils/DateTimeUtils';
import { ChatMsg } from '@/type';

/**
 * Journal State Interface
 *
 * Manages journal-related state including sentiment analysis results, AI interactions,
 * journal entries, chat messages, and loading states. This slice handles all
 * journal functionality including AI-powered sentiment analysis and habit suggestions.
 */
interface JournalState {
  /** Result of AI sentiment analysis including mood and tips */
  sentimentResult: SentimentResult | null;
  /** Boolean flag indicating whether AI operations are in progress */
  isAiLoading: boolean;
  /** Boolean flag indicating whether sentiment analysis is complete */
  isAnalysisDone: boolean;
  /** Current journal entry being viewed or edited */
  journal: JournalType | null;
  /** Error message if journal operations fail */
  error: string | null;
  /** Array of all journals for the current user */
  allJournals: JournalType[] | [];
  /** List of habit suggestions generated by AI based on journal content */
  suggestedHabitListByAi: string[];
  /** Chat messages for AI journal bot interactions */
  chatMessages: ChatMsg[];
  /** Draft journal entry text being composed */
  draftJournalEntry: string;
  /** Chat messages for post-habit completion AI interactions */
  postCompletionChatMessages: ChatMsg[];
}

/**
 * Initial journal state
 *
 * Sets default values for journal state when the slice is initialized
 * or when journal data is reset.
 */
const initialState: JournalState = {
  sentimentResult: null,
  isAiLoading: false,
  isAnalysisDone: false,
  journal: null,
  error: null,
  allJournals: [],
  suggestedHabitListByAi: [],
  chatMessages: [],
  draftJournalEntry: '',
  postCompletionChatMessages: [],
};

/**
 * Journal Slice
 *
 * Redux Toolkit slice that manages journal state and provides
 * async actions for AI-powered journal functionality, CRUD operations,
 * and chat interactions.
 *
 * @example
 * // Access journal state
 * const { sentimentResult, isAiLoading, journal, error } = useSelector(state => state.journal);
 *
 * // Analyze sentiment of journal entry
 * dispatch(analyzeSentimentAction({ journalEntry: 'text', userId: 'user123' }));
 *
 * // Save journal entry
 * dispatch(saveJournalEntryAction({ sentimentResult, journalEntry: 'text', journalDate: '2024-01-01', userId: 'user123' }));
 */
const journalSlice = createSlice({
  name: 'journal',
  initialState,
  reducers: {
    /**
     * Resets journal state to initial values
     *
     * Clears all journal data and returns to initial state.
     * Typically used when user logs out or when clearing app data.
     *
     * @returns Initial journal state
     */
    resetJournal: () => initialState,

    /**
     * Sets chat messages for AI journal bot
     *
     * Replaces the entire chat messages array with new messages.
     * Used to initialize or reset chat conversations.
     *
     * @param state - Current journal state
     * @param action - Payload containing array of chat messages
     */
    setChatMessages: (state, action: PayloadAction<ChatMsg[]>) => {
      state.chatMessages = action.payload;
    },

    /**
     * Appends new chat messages to existing conversation
     *
     * Adds new messages to the end of the current chat messages array.
     * Used to continue ongoing conversations.
     *
     * @param state - Current journal state
     * @param action - Payload containing array of new chat messages
     */
    appendChatMessages: (state, action: PayloadAction<ChatMsg[]>) => {
      state.chatMessages = [...state.chatMessages, ...action.payload];
    },

    /**
     * Sets the analysis completion status
     *
     * Updates the flag indicating whether sentiment analysis is complete.
     * Used to control UI states and user feedback.
     *
     * @param state - Current journal state
     * @param action - Payload containing boolean completion status
     */
    setIsAnalysisDone: (state, action: PayloadAction<boolean>) => {
      state.isAnalysisDone = action.payload;
    },

    /**
     * Sets the draft journal entry text
     *
     * Updates the draft text being composed by the user.
     * Used for real-time text input and auto-save functionality.
     *
     * @param state - Current journal state
     * @param action - Payload containing draft text string
     */
    setDraftJournalEntry: (state, action: PayloadAction<string>) => {
      state.draftJournalEntry = action.payload;
    },

    /**
     * Sets AI loading state
     *
     * Updates the flag indicating whether AI operations are in progress.
     * Used to show loading indicators and prevent multiple simultaneous requests.
     *
     * @param state - Current journal state
     * @param action - Payload containing boolean loading status
     */
    setAiLoading: (state, action: PayloadAction<boolean>) => {
      state.isAiLoading = action.payload;
    },

    /**
     * Sets post-completion chat messages
     *
     * Replaces the entire post-completion chat messages array.
     * Used to initialize or reset post-habit completion AI interactions.
     *
     * @param state - Current journal state
     * @param action - Payload containing array of chat messages
     */
    setPostCompletionChatMessages: (
      state,
      action: PayloadAction<ChatMsg[]>,
    ) => {
      state.postCompletionChatMessages = action.payload;
    },

    /**
     * Appends new post-completion chat messages
     *
     * Adds new messages to the end of the post-completion chat messages array.
     * Used to continue ongoing post-completion conversations.
     *
     * @param state - Current journal state
     * @param action - Payload containing array of new chat messages
     */
    appendPostCompletionChatMessages: (
      state,
      action: PayloadAction<ChatMsg[]>,
    ) => {
      state.postCompletionChatMessages = [
        ...state.postCompletionChatMessages,
        ...action.payload,
      ];
    },
  },
  extraReducers: builder => {
    handleSentimentAnalysisAction(builder);
    handleFetchJournal(builder);
    handleFetchAllJournals(builder);
    handleDeleteJournal(builder);
    handleHabitListByAI(builder);
  },
});

// ============================================================================
// ASYNC THUNKS
// ============================================================================

/**
 * Async thunk to analyze sentiment of journal entry
 *
 * Performs AI-powered sentiment analysis on user's journal text to determine
 * mood and provide personalized tips and suggestions.
 *
 * @example
 * // Analyze sentiment of journal entry
 * dispatch(analyzeSentimentAction({ journalEntry: 'Today was great!', userId: 'user123' }));
 *
 * @param journalEntry - Text content to analyze
 * @param userId - Unique identifier for the user
 * @returns Promise resolving to sentiment analysis result
 */
export const analyzeSentimentAction = createAsyncThunk(
  'journal/analyzeSentiment',
  async (
    { journalEntry, userId }: { journalEntry: string; userId: string },
    { dispatch },
  ): Promise<BaseResponseType<SentimentResult>> => {
    // Perform AI analysis
    const sentimentResponse = await analyzeSentiment(journalEntry);
    return sentimentResponse;
  },
);

/**
 * Async thunk to save journal entry
 *
 * Saves a completed journal entry to the database with sentiment analysis results,
 * AI tips, and metadata. Also invalidates history cache to refresh analytics.
 *
 * @example
 * // Save journal entry with sentiment analysis
 * dispatch(saveJournalEntryAction({
 *   sentimentResult: analysisResult,
 *   journalEntry: 'Today was productive',
 *   journalDate: '2024-01-01',
 *   userId: 'user123'
 * }));
 *
 * @param sentimentResult - Result of sentiment analysis
 * @param journalEntry - Text content of the journal entry
 * @param journalDate - Date for the journal entry (formatted string)
 * @param userId - Unique identifier for the user
 */
export const saveJournalEntryAction = createAsyncThunk(
  'journal/saveJournalEntry',
  async (
    {
      sentimentResult,
      journalEntry,
      journalDate,
      userId,
    }: {
      sentimentResult: SentimentResult;
      journalEntry: string;
      journalDate: string;
      userId: string;
    },
    { dispatch },
  ) => {
    const journalToSave = {
      userId,
      journalEntry,
      journalDate: journalDate, // Already formatted in screen
      sentimentLabel: sentimentResult?.mood.moodLabel,
      sentimentScore: sentimentResult.mood.moodLevel,
      aiTips: sentimentResult.tip,
      updatedAt: new Date().toISOString(),
    };

    // Saving in firestore
    const saveRes = await saveJournalEntry(journalToSave);
    dispatch(invalidateHistoryCache());
  },
);

/**
 * Async thunk to fetch journal entry by date
 *
 * Retrieves a specific journal entry for a user on a given date.
 * Used to load existing entries for editing or viewing.
 *
 * @example
 * // Fetch journal entry for specific date
 * dispatch(getJournalEntry({ userId: 'user123', journalDate: '2024-01-01' }));
 *
 * @param userId - Unique identifier for the user
 * @param journalDate - Date to fetch journal entry for (formatted string)
 * @returns Promise resolving to journal entry or null
 */
export const getJournalEntry = createAsyncThunk(
  'journal/getJournalEntry',
  async ({ userId, journalDate }: { userId: string; journalDate: string }) => {
    const res = await fetchJournalEntry(userId, journalDate);
    if (res.success) return res.data || null;
    throw new Error(res.msg || 'Failed to fetch journal entry');
  },
);

/**
 * Async thunk to fetch all journals for a user
 *
 * Retrieves all journal entries for a specific user.
 * Used to display journal history and manage entries.
 *
 * @example
 * // Fetch all journals for user
 * dispatch(fetchAllJournalsByUserId('user123'));
 *
 * @param userId - Unique identifier for the user
 * @returns Promise resolving to array of journal entries
 */
export const fetchAllJournalsByUserId = createAsyncThunk(
  'journal/fetchAllJournalsByUserId',
  async (userId: string) => {
    const journals: BaseResponseType<JournalType[]> =
      await fetchAllJournalsForUser(userId);
    return journals;
  },
);

/**
 * Async thunk to delete journal entry
 *
 * Removes a specific journal entry from the database.
 * Used to allow users to delete unwanted or incorrect entries.
 *
 * @example
 * // Delete specific journal entry
 * dispatch(deleteJournalById({ userId: 'user123', journalId: 'journal456' }));
 *
 * @param userId - Unique identifier for the user
 * @param journalId - Unique identifier for the journal entry
 * @returns Promise resolving to deletion result with journal ID
 */
export const deleteJournalById = createAsyncThunk(
  'journal/deleteJournalById',
  async ({ userId, journalId }: { userId: string; journalId: string }) => {
    const response = await deleteJournalEntry(userId, journalId);
    return { journalId, ...response };
  },
);

/**
 * Async thunk to get habit suggestions from AI
 *
 * Uses AI to analyze journal content and mood to suggest relevant habits
 * that could help improve the user's well-being.
 *
 * @example
 * // Get habit suggestions based on journal
 * dispatch(getHabitsByJournalAction({
 *   moodLabel: 'Happy',
 *   journalEntry: 'Feeling great today!'
 * }));
 *
 * @param moodLabel - Label describing the user's mood
 * @param journalEntry - Text content of the journal entry
 * @returns Promise resolving to array of suggested habit strings
 */
export const getHabitsByJournalAction = createAsyncThunk(
  'journal/getHabitsByJournal',
  async ({
    moodLabel,
    journalEntry,
  }: {
    moodLabel: string;
    journalEntry: string;
  }): Promise<BaseResponseType<string[]>> => {
    // Perform AI analysis
    const habitListResponse = await suggestHabitsFromAI(
      moodLabel,
      journalEntry,
    );
    return habitListResponse;
  },
);

// ============================================================================
// HELPER FUNCTIONS FOR EXTRA REDUCERS
// ============================================================================

/**
 * Handles sentiment analysis action states
 *
 * Manages loading, success, and error states for sentiment analysis operations.
 * Updates sentiment result, loading state, and error handling.
 *
 * @param builder - Redux Toolkit builder for adding extra reducers
 */
const handleSentimentAnalysisAction = (
  builder: ActionReducerMapBuilder<JournalState>,
) => {
  builder
    .addCase(analyzeSentimentAction.pending, state => {
      state.isAiLoading = true;
    })
    .addCase(analyzeSentimentAction.fulfilled, (state, action) => {
      if (action.payload.success && action.payload.data) {
        state.sentimentResult = action.payload.data;
        state.error = null;
        state.isAiLoading = false;
      } else {
        state.sentimentResult = null;
        state.error = action.payload.msg || 'Failed to analyze sentiment';
        state.isAiLoading = false;
      }
    })
    .addCase(analyzeSentimentAction.rejected, (state, action) => {
      state.sentimentResult = null;
      state.error = action.error.message || 'Failed to analyze sentiment';
      state.isAiLoading = false;
    });
};

/**
 * Handles journal fetch action states
 *
 * Manages success and error states for fetching individual journal entries.
 * Updates journal state and error handling.
 *
 * @param builder - Redux Toolkit builder for adding extra reducers
 */
const handleFetchJournal = (builder: ActionReducerMapBuilder<JournalState>) => {
  builder
    .addCase(getJournalEntry.fulfilled, (state, action) => {
      state.journal = action.payload;
      state.error = null;
    })
    .addCase(getJournalEntry.rejected, (state, action) => {
      state.error = action.error.message || 'Failed to fetch journal entry';
      state.journal = null;
    });
};

/**
 * Handles fetch all journals action states
 *
 * Manages loading, success, and error states for fetching all user journals.
 * Updates allJournals array and error handling.
 *
 * @param builder - Redux Toolkit builder for adding extra reducers
 */
const handleFetchAllJournals = (
  builder: ActionReducerMapBuilder<JournalState>,
) => {
  builder
    .addCase(fetchAllJournalsByUserId.pending, (state, action) => {
      (state.allJournals = []), (state.error = null);
    })
    .addCase(fetchAllJournalsByUserId.fulfilled, (state, action) => {
      if (action.payload.success && action.payload.data) {
        state.allJournals = action.payload.data;
      } else {
        state.error = action.payload.msg || 'Failed to fetch all Journals';
      }
    })
    .addCase(fetchAllJournalsByUserId.rejected, (state, action) => {
      state.error = action.error.message || 'Failed to fetch all journals';
      state.allJournals = [];
    });
};

/**
 * Handles delete journal action states
 *
 * Manages success and error states for journal deletion operations.
 * Updates allJournals array by removing deleted entries and error handling.
 *
 * @param builder - Redux Toolkit builder for adding extra reducers
 */
const handleDeleteJournal = (
  builder: ActionReducerMapBuilder<JournalState>,
) => {
  builder
    .addCase(deleteJournalById.fulfilled, (state, action) => {
      if (action.payload.success) {
        state.allJournals = state.allJournals.filter(
          j => j.id !== action.payload.journalId,
        );
      } else {
        state.error = action.payload.msg || 'Failed to delete journal';
      }
    })
    .addCase(deleteJournalById.rejected, (state, action) => {
      state.error = action.error.message || 'Failed to delete journal';
    });
};

/**
 * Handles AI habit suggestions action states
 *
 * Manages loading, success, and error states for AI-powered habit suggestions.
 * Updates suggestedHabitListByAi array, loading state, and error handling.
 *
 * @param builder - Redux Toolkit builder for adding extra reducers
 */
const handleHabitListByAI = (
  builder: ActionReducerMapBuilder<JournalState>,
) => {
  builder.addCase(getHabitsByJournalAction.pending, state => {
    state.isAiLoading = true;
  });
  builder.addCase(getHabitsByJournalAction.fulfilled, (state, action) => {
    if (action.payload.success && action.payload.data) {
      state.isAiLoading = false;
      state.error = null;
      state.suggestedHabitListByAi = action.payload.data ?? [];
    } else {
      state.isAiLoading = false;
      state.error = action.payload.msg || 'Failed to fetch habits';
      state.suggestedHabitListByAi = action.payload.data ?? [];
    }
  });
  builder.addCase(getHabitsByJournalAction.rejected, (state, action) => {
    state.isAiLoading = false;
    state.error = action.error.message || 'Failed to fetch habits';
    state.suggestedHabitListByAi = [];
  });
};

// Export actions for use in components
export const {
  resetJournal,
  setChatMessages,
  appendChatMessages,
  setPostCompletionChatMessages,
  appendPostCompletionChatMessages,
  setIsAnalysisDone,
  setDraftJournalEntry,
  setAiLoading,
} = journalSlice.actions;

// Export reducer for store configuration
export default journalSlice.reducer;
